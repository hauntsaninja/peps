PEP: 9999
Title: Support for TOML in the Standard Library
Author: Taneli Hukkinen, Shantanu Jain <hauntsaninja at gmail.com>
Sponsor: TODO
PEP-Delegate: TODO
Discussions-To: TODO
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 01-Jan-2022
Python-Version: 3.11
Post-History: 1900-01-01


Abstract
========

This proposes adding a module, ``tomllib``, to the standard library for parsing
and writing TOML. [1]_


Motivation
==========

The TOML format is the format of choice for Python packaging, as evidenced by
:pep:`517`, :pep:`518` and :pep:`621`. Including TOML support in the standard
library helps avoid bootstrapping problems for Python build tools. Currently
most Python build tools need to vendor a TOML parsing library.

Python tools are increasingly configurable via TOML, for examples: ``black``,
``mypy``, ``pytest``, ``tox``, ``pylint``, ``isort``. Those that are not, such
as ``flake8``, cite the lack of standard library support as a `main reason why
<https://github.com/PyCQA/flake8/issues/234#issuecomment-812800657>`_.

Given the special place TOML already has in the Python ecosystem, it makes sense
for this to be an included battery.

Finally, TOML as a format is increasingly popular (some reasons for this are
outlined in PEP 518). Hence this is likely to be a generally useful addition,
even looking beyond the needs of Python packaging and Python tooling: various
Python TOML libraries have about 2000 reverse dependencies on PyPI. For
comparison, ``requests`` has about 28k reverse dependencies.


Rationale
=========

This PEP proposes basing the standard library support for TOML on the third party
libraries ``tomli`` [2]_ and ``tomli-w`` [3]_.

Many projects have recently switched to using ``tomli``, for example, ``pip``,
``build``, ``pytest``, ``mypy``, ``black``, ``flit``, ``coverage``,
``setuptools-scm``, ``cibuildwheel``.

These libraries are actively maintained and well-tested. ``tomli`` is about 800
lines of code with 100% test coverage. ``tomli-w`` is about 200 lines of code with
100% test coverage.


Specification
=============

Read API

.. code-block::

   def load(fp: SupportsRead[bytes], /, *, parse_float: Callable[[str], Any] = float) -> dict[str, Any]: ...
   def loads(s: str, /, *, parse_float: Callable[[str], Any] = float) -> dict[str, Any]: ...

``tomllib.load`` deserializes a ``.read()``-supporting binary file containing a
TOML document to a Python object.

``tomllib.loads`` deserializes a str instance containing a TOML document to a
Python object.

``parse_float`` is a function that takes a string and returns a float, as with ``json.load``.
For example, ``decimal.Decimal`` in cases where precision is important.

``tomllib.TOMLDecodeError`` is raised in the case of invalid TOML.

Write API

.. code-block::

   def dump(obj: Mapping[str, Any], fp: SupportsWrite[bytes], /, *, multiline_strings: bool = False) -> None: ...
   def dumps(obj: Mapping[str, Any], /, *, multiline_strings: bool = False) -> str: ...


``tomllib.dumps`` serialize obj as a TOML formatted stream to a
``.write()``-supporting file-like object.

``tomllib.dump`` serializes an object to a TOML formatted str.


``multiline_strings`` controls whether strings containing newlines are written
as multiline strings. This defaults to False in case users wish to ensure
preservation of newline byte sequences.

TODO: describe types supported


Maintenance Implications
========================

Stability of TOML
-----------------

The release of TOML v1 in January 2021 indicates stability. Empirically, TOML
has proven to be a stable format even prior to the release of TOML v1. From the
`changelog <https://github.com/toml-lang/toml/blob/master/CHANGELOG.md>`_, we
see TOML has had no major changes since April 2020 and has had two releases in
the last five years.

In the event of changes to the TOML specification, we could treat minor
revisions as bugfixes and update the implementation in place. In the event of
major breaking changes, we should preserve support for TOML v1.

Maintainability of proposed implementation
------------------------------------------

The proposed implementation (``tomli`` and ``tomli-w``) is in pure Python, well
tested and combined weigh under 1000 lines of code. They are both minimalistic,
offering a smaller API surface area than other TOML implementations.

The author of ``tomli`` is willing to help integrate ``tomli`` into the standard
library and help maintain it, `as per this
<https://github.com/hukkin/tomli/issues/141#issuecomment-998018972>`_.

There is unlikely to be demand for an extension module, since there is
relatively less need for performance in parsing TOML: it's rare for application
bottleneck to be reading configuration. Users with extreme performance needs can
use a third party library (as is already often the case with JSON, despite a
stdlib extension module).

TOML support a slippery slope for other things
----------------------------------------------

As discussed in motivations, TOML holds a special place in the Python ecosystem.
This chief reason to include TOML in the standard library does not apply to
other formats, such as YAML or MessagePack.

In addition, the simplicity of TOML can help serve as a dividing line, for
example, YAML is large and complicated.


Backwards Compatibility
=======================

This will have no backwards compatibility issues as it will create a new API.

Note that a current open issue is whether to use the ``toml`` name for the
package instead of ``tomllib``, in which case there will be backwards
compatibility implications for users who have pinned versions of the current
``toml`` PyPI package.


Security Implications
=====================

Errors in the implementation could cause potential security issues. However, the
implementation will be in pure Python, which reduces surface area of attack.


How to Teach This
=================

The API of ``tomllib`` mimics that of other well-established file format libraries,
such as ``json`` and ``pickle``.


Reference Implementation
========================

Link to any existing implementation and details about its state, e.g. proof-of-concept.

https://github.com/hukkin/tomli

https://github.com/hukkin/tomli-w


Rejected Ideas
==============

Roundtripping style
-------------------

In general, ``tomllib.dumps(tomllib.loads(x))`` may not equal ``x``, since we
make no effort to preserve comments, whitespace or other stylistic choices.

Style preservation would allow tools to losslessly edit TOML files. Since TOML
is intended as human-readable and human-editable configuration, it's important
to preserve human markup.

However, only a relatively small fraction of use cases require losslessly
editing TOML, as judged by reverse dependencies the style preserving ``tomlkit``
library compared to that of other third party toml libraries. In particular, we
don't need it for the core Python packaging use cases or for tools that merely
need to read configuration.

Since this would make both the implementation and the API more complex, it seems
better to relegate this additional functionality to third party libraries.

Basing on another TOML implementation
-------------------------------------

Potential alternatives include:

* ``tomlkit``.
  ``tomlkit`` is well established, actively maintained and supports TOML v1.
  An important difference is that ``tomlkit`` supports style roundtripping. As a
  result, it has a more complex API and implementation (about 5x as much code as
  ``tomli``). The author does not believe that ``tomlkit`` is a good choice for
  the standard library.

* ``toml``.
  ``toml`` is a widely used library. However, it is not actively maintained and
  does not support TOML v1. Its API is more complex than that of ``tomli``.
  It has some very limited ability and mostly unused ability to preserve style
  through an undocumented decoder API. It has the ability to customise output
  style through a complicated encoder API.
  For more details on API differences, refer to this `discuss post
  <https://discuss.python.org/t/adopting-recommending-a-toml-parser/4068/78>`_.

* ``pytomlpp``.
  ``pytomlpp`` is a Python wrapper for the C++ project ``toml++``. Pure Python
  libraries are easier to maintain than extension modules.

* ``rtoml``.
  ``rtoml`` is a Python wrapper for the Rust project ``toml-rs`` and hence has
  similar shortcomings to ``pytomlpp``. In addition, it does not support TOML v1.

* Writing from scratch.
  It's unclear what we would get from this: ``tomli`` meets our needs and the
  author is willing to help with its inclusion in the standard library.

Only including an API for reading TOML
--------------------------------------

There are several reasons to not include an API for writing TOML:

The ability to write TOML is not needed for the use cases that motivate this
PEP: for core Python packaging use cases or for tools that need to read
configuration.

As discussed in the previous section, use cases that involve editing TOML (as
opposed to writing brand new TOML) are better served by a style preserving
library.

Values in TOML can be represented in multiple ways. To the extent that users
want control over how the output TOML ends up being formatted (how to format
strings, when to inline arrays or tables, how much to indent, whether to reorder
contents, etc), they will not be served well by the proposed API.

The standard library does not need to do everything and if we feel that most
users are better served by more powerful third party write APIs, exclusion is
acceptable (and could be revisited later).

However, users will likely expect a write API to be available for consistency.
Empirically, writing TOML seems useful, e.g. ``toml.dump`` is used about 30% as
often as ``toml.load`` based on https://grep.app

Even a simple API is capable of serving common use cases, such as testing code
that loads TOML or writing simple or boilerplate TOML.
TODO: about 1/5 uses of ``toml.dump[s]`` are in tests, estimate other simple use cases

If we keep feature set narrow, a write API shouldn't be too much additional
burden. The proposed implementation is about 200 lines of code.

Finally, an open issue is whether we're able to re-use the ``toml`` package name.
If so, having a basic write API could reduce disruption for affected users.


Assorted API details
--------------------

Controlling the type of mappings returned by ``tomllib.load[s]``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This would work similarly to common uses for the ``object_hook`` argument in
``json.load[s]``.

Such an argument is not necessary for the core use cases outlined in the
motivation section. The absence of this can be pretty easily worked around using
a wrapper class or transformer function. Finally, support could be added later
in a backward compatible way.

The ``toml`` library on PyPI supports this feature using the ``_dict`` argument. We were
able to find several uses of this on https://grep.app, however, almost all of
them were passing ``_dict=OrderedDict`` which should no longer be necessary
since Python 3.7. There were two instances of legitimate use: in one case, a
custom class was passed for friendlier KeyErrors, in another case, several
lookup and mutation methods to the custom class (e.g. to help resolve dotted
keys).

Types accepted by the first argument of ``tomllib.load``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``toml`` library on PyPI allows passing path-like objects (and lists of
path-like objects, reading the first path that exists). Doing this would be
inconsistent with ``json.load``, ``pickle.load``, etc. If we agree consistency
with other stdlib modules is desirable, this is somewhat out of scope for this
PEP. This can easily and perhaps more explicitly be worked around in user code.

The proposed API takes a ``SupportsRead[bytes]``, while ``toml.load`` takes a
``SupportsRead[str]`` and ``json.load`` takes ``SupportsRead[str | bytes]``.
While slightly opinionated, this was changed in ``tomli`` v1.2 to a)
ensure utf-8 is the encoding used, b) avoid incorrectly parsing single carriage
returns as valid TOML due to universal newlines.

Allowing users more control over formatting ``tomllib.dump[s]`` output
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As mentioned, TOML values can be represented in multiple ways, so inevitably,
people will have strong opinions over how to do so.

The ``toml`` library on PyPI supports this using custom subclasses of
``toml.TomlEncoder``. There are a handful of instances of this that can be found
on https://grep.app. However, the API to do this is not particularly clean.

A non-exhaustive list of potential options users may want control over:

* How to format strings
* When to inline arrays or tables
* How much to indent
* Whether to reorder contents
* Whether to use dotted keys

In several cases, users could enforce TOML formatting by using an autoformatter
of their choice at a later point.

We acknowledge that supporting ``multiline_strings`` is something of an
exception to this, if controversial we can err on the side of simplicity and
remove it.

Allowing users more control over ``tomllib.dump[s]`` serialisation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It could be useful to add the equivalent of the ``default`` argument in ``json.dump``
to allow users to specify how custom types should be serialised.

The ``toml`` library on PyPI supports this using custom subclasses of
``toml.TomlEncoder``. However, we could find two instances of using
``toml.TomlEncoder`` to accomplish this kind of thing on https://grep.app, one
of which was to add support to ``toml`` for dumping ``decimal.Decimal``.

TOML is used more for configuration than serialisation of arbitrary data, so
users are perhaps less likely to require custom serialisation than with say
JSON. Support for this could be added in a backward compatible way.

TODO: talk about output validation for ``dump[s]``

Open Issues
===========

Package name
------------

Ideally, we would be able to use the ``toml`` package name. The ``toml`` package
on PyPI is both widely used and not actively maintained.

If the maintainer of ``toml`` resurfaced and was willing to give up the ``toml``
name on PyPI, we could repurpose the PyPI package as a stdlib backport. However,
this would still be breaking for users who have pinned current versions of the
``toml`` package and have upgraded Python versions. The two API
incompatibilities that most users of current ``toml`` would run into are a)
different acceptable types to the first argument of ``toml.load``, b) use of
``dump[s]`` if we choose not to include a write API.
For more details on API differences, refer to this `discuss post
<https://discuss.python.org/t/adopting-recommending-a-toml-parser/4068/78>`_.

This PEP proposes ``tomllib``. This mirrors ``plistlib`` (another file format
module in the standard library), as well as several others such as ``pathlib``,
``graphlib``, etc.

Other bikesheds include:

* ``tomlparser``. This mirrors ``configparser``, but is perhaps slightly less
  appropriate if we include a write API.
* ``tomli``. This assumes we use ``tomli`` as the basis for implementation.
* ``toml``, but under some namespace, such as ``parser.toml`` or
  ``decoder.toml``. However, this is sort of awkward, especially since existing
  libraries like ``json``, ``pickle``, ``marshal``, ``html`` etc. will not be
  included in the namespace.

Only including an API for reading TOML
--------------------------------------

Currently discussed in rejected ideas but a major open issue.


TODO: Random things
===================

Previous discussion:

* https://bugs.python.org/issue40059
* https://mail.python.org/archives/list/python-ideas@python.org/thread/IWJ3I32A4TY6CIVQ6ONPEBPWP4TOV2V7/
* https://mail.python.org/pipermail/python-dev/2019-May/157405.html
* https://github.com/hukkin/tomli/issues/141
* https://discuss.python.org/t/adopting-recommending-a-toml-parser/4068/84

Useful https://grep.app searches (note, ignore vendored):

* toml.load[s] usage https://grep.app/search?q=toml.load&filter[lang][0]=Python
* toml.dump[s] usage https://grep.app/search?q=toml.dump&filter[lang][0]=Python
* TomlEncoder subclasses https://grep.app/search?q=TomlEncoder%29%3A&filter[lang][0]=Python


References
==========

.. [1]
   TOML: Tom's Obvious Minimal Language
   https://toml.io/en/

.. [2]
   tomli
   https://github.com/hukkin/tomli

.. [3]
   tomli-w
   https://github.com/hukkin/tomli-w


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
    Local Variables:
    mode: indented-text
    indent-tabs-mode: nil
    sentence-end-double-space: t
    fill-column: 70
    coding: utf-8
    End:
